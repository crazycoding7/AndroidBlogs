### View绘制流程

[TOC]

#### 1. 基础知识点

##### 1.  View绘制的起点

​	ViewRootImpl类的`performTraversals()`是执行遍历的方法。

```java
public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
    	...
      requestLayout();   // 1.触发绘制流程 
      // 通信WMS添加显示view  2. 通过IPC 执行WMS.addWindow方法。
      // 通过WindowSession进行IPC调用，将View添加到Window上
      // mWindow即W类，用来接收WMS信息；同时通过InputChannel接收触摸事件回调。
      res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,
                            getHostVisibility(), mDisplay.getDisplayId(),
                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,
                            mAttachInfo.mOutsets, mInputChannel);
    	...
}
@Override
public void requestLayout() {
  if (!mHandlingLayoutInLayoutRequest) {
    // 检查发起布局请求的线程是否为主线程  
    checkThread();
    mLayoutRequested = true;
    scheduleTraversals();
  }
}
// 开始执行遍历三大流程
private void performTraversals() { 
...... 
int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); 
int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); 
...... 
performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); // mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); 
......
performLayout(lp, mWidth, mHeight); // mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight());
...... 
performDraw(); // mView.draw(canvas); 
......
}
```

##### 2. MeasureSpec原理

- what: MeasureSpec类是View类的一个静态内部类，一个MeasureSpec封装了从父容器**传递**给子容器的**布局要求(规格参数测量参数)**。子View的MeasureSpec是有父类的MS和子类本身的LayoutParams共同决定。

- Why: 主要用于父类向子类传递测量参数。

- how:组成部分

  由一个`int`类型的数字表示，分为2部分：mode(模式前两位)+size(大小后30位)；

  mode类型：

  1. UNSPECIFIED：不对View大小做限制，如：ListView，ScrollView；
  2. EXACTLY：确切的大小，如：100dp或者march_parent；
  3. AT_MOST：大小不可超过某数值，如：wrap_content。

- **如何计算某个View的MS？**

  ```java
  // spec:父类宽或高ms,padding:占用空间，childDimesion子view大小
  public static int getChildMeasureSpec(int spec, int padding, int childDimension) {
      int specMode = MeasureSpec.getMode(spec);
      int specSize = MeasureSpec.getSize(spec);
      int size = Math.max(0, specSize - padding);
      int resultSize = 0;
      int resultMode = 0;
      switch (specMode) {
      // Parent has imposed an exact size on us
      若父View是EXACTLY，则父View有确切数值或者march_parent
      case MeasureSpec.EXACTLY:
          若子View的childDimension大于0，则表示有确切数值，则子View大小为其本身且mode是EXACTLY
          if (childDimension >= 0) {
              resultSize = childDimension;
              resultMode = MeasureSpec.EXACTLY;
          } 
          若子View的childDimension是MATCH_PARENT，则子View的大小为父View的大小且mode是EXACTLY
          else if (childDimension == LayoutParams.MATCH_PARENT) {
              // Child wants to be our size. So be it.
              resultSize = size;
              resultMode = MeasureSpec.EXACTLY;
          } 
          若子View的childDimension是WRAP_CONTENT，则子View的大小为父View的大小且mode是AT_MOST，表示最大不可超过父View数值
          else if (childDimension == LayoutParams.WRAP_CONTENT) {
              // Child wants to determine its own size. It can't be
              // bigger than us.
              resultSize = size;
              resultMode = MeasureSpec.AT_MOST;
          }
          break;
  
      // Parent has imposed a maximum size on us
      若父View是AT_MOST，则父View一般是wrap_content，强给子View最大的值
      case MeasureSpec.AT_MOST:
          若子View的childDimension大于0，则表示有确切数值，则子View大小为其本身且mode是EXACTLY
          if (childDimension >= 0) {
              // Child wants a specific size... so be it
              resultSize = childDimension;
              resultMode = MeasureSpec.EXACTLY;
          } 
          若子View的childDimension是MATCH_PARENT，则子View的大小不超过父View的大小且mode是AT_MOST
          else if (childDimension == LayoutParams.MATCH_PARENT) {
              // Child wants to be our size, but our size is not fixed.
              // Constrain child to not be bigger than us.
              resultSize = size;
              resultMode = MeasureSpec.AT_MOST;
          } 
         若子View的childDimension是WRAP_CONTENT，则子View的大小不超过父View的大小且mode是AT_MOST
          else if (childDimension == LayoutParams.WRAP_CONTENT) {
              // Child wants to determine its own size. It can't be
              // bigger than us.
              resultSize = size;
              resultMode = MeasureSpec.AT_MOST;
          }
          break;
  
      // Parent asked to see how big we want to be
      若父View是UNSPECIFIED，则父View不限制子View大小
      case MeasureSpec.UNSPECIFIED:
      若子View的childDimension大于0，则表示有确切数值，则子View大小为其本身且mode是EXACTLY
          if (childDimension >= 0) {
              // Child wants a specific size... let him have it
              resultSize = childDimension;
              resultMode = MeasureSpec.EXACTLY;
          } 
          若子View的childDimension是MATCH_PARENT，因为父View是UNSPECIFIED，所以子View大小为0
          else if (childDimension == LayoutParams.MATCH_PARENT) {
              // Child wants to be our size... find out how big it should
              // be
              resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
              resultMode = MeasureSpec.UNSPECIFIED;
          }
          若子View的childDimension是WRAP_CONTENT，因为父View是UNSPECIFIED，所以子View大小为0 
          else if (childDimension == LayoutParams.WRAP_CONTENT) {
              // Child wants to determine its own size.... find out how
              // big it should be
              resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
              resultMode = MeasureSpec.UNSPECIFIED;
          }
          break;
      }
      //noinspection ResourceType
      return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
  }
  ```

  总结一下：
   不管父View是何模式，若子View有确切数值，则子View大小就是其本身大小，且mode是EXACTLY；
   若子View是match_parent，则模式与父View相同，且大小同父View（若父View是UNSPECIFIED，则子View大小为0）；
   若子View是wrap_content，则模式是AT_MOST，大小同父View，表示不可超过父View大小（若父View是UNSPECIFIED，则子View大小为0）。

#### 2. 三个阶段

View的整个绘制流程可以分为以下三个阶段：

- measure: 判断是否需要重新计算View的大小，需要的话则计算；
- layout: 判断是否需要重新计算View的位置，需要的话则计算；
- draw: 判断是否需要重新绘制View，需要的话则重绘制。
  这三个子阶段可以用下图来描述(measure和layout可以执行多次)：

![ui_draw](images/ui_view_draw.png)

##### measure阶段

> 



##### layout阶段



##### draw阶段