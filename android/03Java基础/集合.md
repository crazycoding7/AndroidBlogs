### 集合

[TOC]

#### 1. Java集合框架？

##### 介绍

- Map、Collection接口是所有集合框架的父类接口。

- Collection接口的子接口包括：Set和List接口；

- Map(**kv**)接口的实现类主要有：HashMap、TreeMap、HashTable、ConcurrentHashMap以及Propreties等。

- List(**有序可重复**)接口的实现类主要有：ArrayList、LinkedList、Vetor、Stack等。

- Set(**不可重复**)接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等。

  <img src="images/java集合.png" alt="java集合" style="zoom:40%;" />



#### 2. HashMap原理？

##### 存储结构

​	采用**链表散列**的数据结构，即数组和链表组成的，当链表长度大于8，采用红黑树存储。

​	注意：初始容量为16，扩容方式为2N。

```java
/**
 * HashMap数据结构
 * "链表散列"的数据结构，内部实现是一个桶数组，每个桶中存放着一个单链表的头结点。
 *  链表长度大于8，采用红黑树存储。
 */
 static final float DEFAULT_LOAD_FACTOR = 0.75f;  // 默认负载因子！
 static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16   默认容量！

 transient Node<K,V>[] table; // extned Entry<K,V>
 transient int size;
 int threshold;			// 阈值 table.size * loadFactor
 final float loadFactor;

 // 计算hash
 static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
 }
 // 获得key索引
 tab[index = (tableSize - 1) & hash];

 // 大于阈值后，2倍扩容
 newCap = oldCap << 1
```

##### 常见问题

1. 为什么容量总是2的次幂？

   索引位置计算公式： `tab[(n - 1) & hash]`。

   因为 n 永远是2的次幂，所以 n-1 通过 二进制表示，永远都是尾端以连续1的形式表示（00001111，00000011）。当(n - 1) 和 hash 做与运算时，会保留hash中 后 x 位的 1(且索引合法)，
   例如 00001111 & 10000011 = 00000011

   好处：

   - &(与)运算符比%(取模)运算速度快；
   - 能保证索引值不会超出长度；
   - 当n为2次幂时，满足公式：`(n - 1) & hash = hash % n`。

2. 为什么hash计算公式是`(key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16)`?

   实质上是把一个数的低16位和高16位做异或运算，因为前面计算索引公式，只有hash的低x位参与到运算。使高16位也参到hash的运算能减少hash冲突。

3. 为什么默认加载引子选择0.75？

   **提高空间利用率和减少查询成本的折中，主要是泊松分布，0.75的话碰撞最小。**

   加载因子过高，例如为1，虽然减少了空间开销，提高了空间利用率，但同时也增加了查询时间成本；

   加载因子过低，例如0.5，虽然可以减少查询时间成本，但是空间利用率很低，同时提高了rehash操作的次数。

