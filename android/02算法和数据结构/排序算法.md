### 排序算法

[TOC]

![sort](images/排序算法.jpg)

> 当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。

#### 1. 快速排序

**适用场景：**是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是**随机分布时**，快速排序的平均时间最短。

**思想：**快速排序法的基本精神是在数列中找出适当的轴心，然后将数列一分为二(左边都小于等于轴心值，右边大于轴心值)，然后分别对左边与右边数列进行排序。

**复杂度：**O(NlogN)，O(NlogN)。

```java
// 快速排序算法(从小到大)
    public static void quickSort(int[] nums, int begin, int end) {
        int middle = nums[begin];
        int left = begin;
        int right = end;

        if (begin < end) {
            return;
        }

        while (left < right) {
            while (left < right && nums[right] > middle) {
                right--;
            }
            nums[left] = nums[right];

            // 注意等号
            while (left < right && nums[left] <= middle) {
                left++;
            }
            nums[right] = nums[left];

            System.out.println(left + "  " + right);
        }

        nums[left] = middle;

        quickSort(nums, begin, left - 1);
        quickSort(nums, right + 1, end);
    }
```

#### 2. 冒泡排序

**适用场景：**任何。

**思想：** 通过一趟排序，将数组中最大元素移动到最后一个位置，然后继续排第二大元素到倒数第二个位置**（外层循环n-1,内存循环n-1-i）**。

**复杂度:**O(n^2)，O(1)。

```java
public static void sortBubble(int[] nums){
  for (int i=0;i<nums.length-1;i++){
    for (int j=0;j<nums.length-1-i;j++){
      if(nums[j] > nums[j+1] ){
        swap(nums,j,j+1);
      }
    }
  }
}
```

#### 3. 直接插入

**适用场景：** 少量数据，最好有部分是有序的(有序数组O(n)，逆序数组O(n^2))。

**思想：** 在一个有序的数组中为要插入的元素找到指定的插入位置，但这个位置并不一定是最后排序结果中对应元素的最终位置。。

**复杂度:**O(n^2)，O(1)。

```java
  public static void insertSort(int[] nums) {
        for (int i = 1; i < nums.length; i++) {
            int value = nums[i];
            int j = i - 1;

            while (j >= 0 && value < nums[j]) {
                nums[j + 1] = nums[j];
                j--;
            }

            nums[j+1] = value;
        }
    }

```

#### 4. 直接选择

**适用场景：** 开始就有序。

**思想：** 从最小一个元素开始，以此选择放入。数组分成有序区和无序区，初始时整个数组都是无序区，然后每次从无序区选一个最小的元素直接放到有序区的最后，直到整个数组变有序区。

**复杂度:**O(n^2)，O(1)。

初始关键字：『 **8**，5，2，6，9，3，1，4，**0**，7 』

 第一趟排序后：0，『**5**，2，6，9，3，**1**，4，8，7』

 第二趟排序后：0，1，『**2**，6，9，3，5，4，8，7』

 第三趟排序后：0，1，2，『**6**，9，**3**，5，4，8，7』

 第四趟排序后：0，1，2，3，『**9**，6，5，**4**，8，7』 ...

```java
public static void selectSort(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        int minIndex = i;
        for(int j= i+1;j<nums.length;j++){
            if(nums[j]< nums[minIndex]){
                minIndex = j;
            }
        }
        
        swap(nums,i,minIndex);
    }
}
```

#### 5. 堆排序

**适用场景：**任何。

**思想：**堆排序是利用**堆(大顶堆)**这种数据结构而设计的一种排序算法，堆排序是一种**选择排序，**它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。**堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了**

<img src="images/堆排序.png" style="zoom:70%;" />

[参考](https://www.cnblogs.com/chengxiao/p/6129630.html)

#### 6. 归并排序

**适用场景：**任何。

**思想：** 分治法思想(自上而下递归，自下而上迭代)。

[参考](https://www.jianshu.com/p/33cffa1ce613)

