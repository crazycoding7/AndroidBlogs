### 算法题1

[TOC]

> 每个题都考察的是一个知识点和解决思路。需要先分析问题数据规律，然后找出难点或复杂点，最后设计解决方法。

#### 1. 查找数组中的重复数字

**`查重`思想：**每个元素依次与它前面的所有元素对比。

```java
int[] arrays = {2, 3, 1, 0, 2, 5, 3};
jump:for (int i=0;i<arrays.length;i++) {
  int value = arrays[i];
  for (int j=0;j<i;j++){
    if(value == arrays[j]){
      System.out.println("找到了" + value);
      break jump;
    }
  }
}
```

#### 2. 二位数组查找数字(有序)

**`有序`查找思想：**分治思想(二分查找)

> 题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

```java
// 一维数组
public int BinarySearch(int[] array,int x,int left,int right){
        while(left<=right){
            int mid=(left+right)/2;
            if(array[mid]==x){
                return mid;
            }
            if(array[mid]>x)right=mid-1;
            else left=mid+1;
        }
        return -1;
    } 
// 二位数组
int[][] arrays = {
                {1, 4, 7, 11, 15},
                {2, 5, 8, 12, 19},
                {3, 6, 9, 16, 22},
                {10, 13, 14, 17, 24},
                {18, 21, 23, 26, 30}
        };
        
int target = 6;
int row = arrays.length;
int col = arrays[0].length;

// 右上角为起点，依次排除行列(分析规律，找对起点)
for (int i=0,j=arrays[0].length-1;(i>=0 && i<row) && (j>=0 && j<col);){
  if(target == arrays[i][j]){
    System.out.println("找到了"+i + " " + j);
    break;
  }else if(target < arrays[i][j]){
    j--;
  }else{
    i++;
  }
}

```

#### 3. 替换空格

**思想：**分析问题复杂点；

```java
// 推荐使用urlecode、replace、StringBuffer解决。
public static void main(String[] args) {
        String test = "We are happy.";
        // 新count
        int newSize = test.length();
        for (int i=0;i< test.length();i++){
            if(test.charAt(i) == ' '){
                newSize +=2;
            }
        }

        // 遍历赋值
        char[] newTest = new char[newSize];
        int tempJumpIndex=0; // 注意索引跳过
        for (int i=0;i< test.length();i++) {
            if(test.charAt(i) == ' '){
                newTest[i+tempJumpIndex] = '%';
                newTest[i+tempJumpIndex+1] = '2';
                newTest[i+tempJumpIndex+2] = '0';
                tempJumpIndex +=2;
            }else {
                newTest[i+tempJumpIndex] =test.charAt(i);
            }
        }

        System.out.println(newTest);
    }
```

#### 4. 反转链表(从尾到头打印)









- 参考

[1. leetcode](https://leetcode-cn.com/problemset/lcof/)