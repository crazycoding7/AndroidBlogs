### 算法题1

[TOC]

> 每个题都考察的是一个知识点和解决思路。需要先分析问题数据规律，然后找出难点或复杂点，最后设计解决方法。

#### 1. 查找数组中的重复数字

**`查重`思想：**每个元素依次与它前面的所有元素对比。

```java
int[] arrays = {2, 3, 1, 0, 2, 5, 3};
jump:for (int i=0;i<arrays.length;i++) {
  int value = arrays[i];
  for (int j=0;j<i;j++){
    if(value == arrays[j]){
      System.out.println("找到了" + value);
      break jump;
    }
  }
}
```

#### 2. 二位数组查找数字(有序)

**`有序`查找思想：**分治思想(二分查找)

> 题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

```java
// 一维数组
public int BinarySearch(int[] array,int x,int left,int right){
        while(left<=right){
            int mid=(left+right)/2;
            if(array[mid]==x){
                return mid;
            }
            if(array[mid]>x)right=mid-1;
            else left=mid+1;
        }
        return -1;
    } 
// 二位数组
int[][] arrays = {
                {1, 4, 7, 11, 15},
                {2, 5, 8, 12, 19},
                {3, 6, 9, 16, 22},
                {10, 13, 14, 17, 24},
                {18, 21, 23, 26, 30}
        };
        
int target = 6;
int row = arrays.length;
int col = arrays[0].length;

// 右上角为起点，依次排除行列(分析规律，找对起点)
for (int i=0,j=arrays[0].length-1;(i>=0 && i<row) && (j>=0 && j<col);){
  if(target == arrays[i][j]){
    System.out.println("找到了"+i + " " + j);
    break;
  }else if(target < arrays[i][j]){
    j--;
  }else{
    i++;
  }
}

```

#### 3. 替换空格

**思想：**分析问题复杂点；

```java
// 推荐使用urlecode、replace、StringBuffer解决。
public static void main(String[] args) {
        String test = "We are happy.";
        // 新count
        int newSize = test.length();
        for (int i=0;i< test.length();i++){
            if(test.charAt(i) == ' '){
                newSize +=2;
            }
        }

        // 遍历赋值
        char[] newTest = new char[newSize];
        int tempJumpIndex=0; // 注意索引跳过
        for (int i=0;i< test.length();i++) {
            if(test.charAt(i) == ' '){
                newTest[i+tempJumpIndex] = '%';
                newTest[i+tempJumpIndex+1] = '2';
                newTest[i+tempJumpIndex+2] = '0';
                tempJumpIndex +=2;
            }else {
                newTest[i+tempJumpIndex] =test.charAt(i);
            }
        }

        System.out.println(newTest);
    }
```

#### 4. 反转链表(从尾到头打印)

```java
// 1. 思想：头插入法
public static Node reverseByInsert(Node headNode){
        Node temp;
        Node newHead = null;
        while (headNode != null){
            temp = headNode;
            headNode = headNode.next;
            
            temp.next = newHead;
            newHead = temp;
        }
        return newHead;
}
或
public static Node reverseByInsert(Node head) {
        if (head == null || head.next == null) { return head;}
        Node prev, cur, end;
        prev = null;
        cur = head;
        end = head.next;
				// 遍历生成pre
        while (cur != null) {
            cur.next = prev;

            prev = cur;
            cur = end;
            if (end != null) {
                end = end.next;
            }
        }
        return prev;
}  
// 2. 就地反转
public static Node reverseByLocal(Node head) {
       Node cur = head;
       Node next = cur.next;

        Node temp;
        while (next != null){
           temp = next.next;
           next.next = cur;
           cur = next;
           next = temp;
       }

       head.next = null;
       head = cur;
       return head;
}
// 3. 思想：递归到尾部，依次翻转断链
public static Node reverse(Node headNode){
        if(headNode == null || headNode.next == null){
            return headNode;
        }

        Node newNode = reverse(headNode.next);
        headNode.next.next = headNode;  // node翻转
        headNode.next = null;           // 断链
        return newNode;
}
```

[leetcode](https://leetcode-cn.com/problems/reverse-linked-list)

#### 5. 两两交换链表中的节点

[leetcode](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

#### 6. 判断链表是否有环

[leetcode](https://leetcode-cn.com/problems/linked-list-cycle/)

#### 7. 字符串合法检查("({[]})")

栈实现

#### 8. 用栈实现队列

#### 9. 用队里实现栈

堆实现、二叉搜索树实现。

#### 10. 优先队列

堆实现：二叉堆(jdk默认小顶堆实现PriorityQueue)、斐波拉契堆(效率最高)等。

堆实现区别：

![堆实现](images/struct-heap.png)

#### 11. 数据流中第K大元素

PriorityQueue

#### 12. 滑动窗口最大值(239)

解法：MaxHeap(优先队列)、Deque(ArrayDeque双端队列，最优解法)









- 参考

[1. leetcode](https://leetcode-cn.com/problemset/lcof/)

[2. big-O](https://www.bigocheatsheet.com/)